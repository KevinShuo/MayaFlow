# -*- coding: utf-8 -*-
import os
import re

import yaml
from enum import Enum
from m_maya_py2.src.attribute import MayaAttributePy2
from m_maya_py2.src.base import MayaBasePy2
from m_maya_py2.src.file import MayaFileOperatorPy2
from m_maya_py2.util import get_shader_attribute_data


class MaterialType(Enum):
    aiStandardSurface = "aiStandardSurface"


class RenderType(Enum):
    Arnold = 0
    Redshift = 1


class MayaShaderBuildPy2:
    def __init__(self):
        self.maya_base = MayaBasePy2()
        self.shader = None
        self.sg_node = None

    def create_shader(self, material_type, material_name):
        """
            创建shader

        Args:
            material_type: 材质类型
            material_name: 材质名字

        Returns:

        """
        material = self.maya_base.cmds.shadingNode(material_type.value, asShader=True, name=material_name)
        shading_group = self.maya_base.cmds.sets(name="{}SG".format(material), renderable=True, noSurfaceShader=True,
                                                 empty=True)
        self.maya_base.cmds.connectAttr('{}.outColor'.format(material), '{}.surfaceShader'.format(shading_group),
                                        force=True)
        self.shader = material
        self.sg_node = shading_group
        return self

    def create_displacement(self, name):
        displacementShader = self.maya_base.cmds.shadingNode("displacementShader", asShader=True, name=name)
        self.maya_base.cmds.connectAttr("{}.displacement".format(displacementShader),
                                        "{}.displacementShader".format(self.sg_node),
                                        f=True)
        return displacementShader

    def create_file(self, name, path, color_space):
        file_node = self.maya_base.cmds.shadingNode('file', asTexture=True, isColorManaged=True, name=name)
        self.maya_base.cmds.setAttr("{}.fileTextureName".format(file_node), str(path), type="string")
        self.maya_base.cmds.setAttr("{}.colorSpace".format(file_node), color_space, type="string")
        self.maya_base.cmds.setAttr("{}.ignoreColorSpaceFileRules".format(file_node), 1)
        return file_node

    def create_ai_image_node(self, name, path, color_space):
        file_node = self.maya_base.cmds.shadingNode('aiImage', asTexture=True, isColorManaged=True, name=name)
        new_path = re.sub(r"\.\d+\.", ".<UDIM>.", str(path))
        self.maya_base.cmds.setAttr("{}.filename".format(file_node), new_path, type="string")
        self.maya_base.cmds.setAttr("{}.colorSpace".format(file_node), color_space, type="string")
        # self.maya_base.cmds.setAttr(f"{file_node}.useFrameExtension", 1)
        return file_node

    def create_normal_node(self, name):
        if not self.shader:
            raise AttributeError('shader not created')
        # aiNormalMap
        normal_node = self.maya_base.cmds.shadingNode('aiNormalMap', asShader=True, name=name)
        self.maya_base.cmds.connectAttr("{}.outValue".format(normal_node), "{}.normalCamera".format(self.shader))
        return normal_node

    def connect_file_to_shader(self, file_node, connect_attr, is_color):
        if not self.shader:
            raise AttributeError('shader not created')
        if is_color:
            self.maya_base.cmds.connectAttr("{}.outColor".format(file_node), "{}.{}".format(self.shader, connect_attr),
                                            f=True)
        else:
            if self.maya_base.cmds.nodeType(file_node) == "file":
                # outAlpha
                self.maya_base.cmds.connectAttr("{}.outAlpha".format(file_node),
                                                "{}.{}".format(self.shader, connect_attr), f=True)
                self.maya_base.cmds.setAttr("{}.alphaIsLuminance".format(file_node), 1)
            else:
                self.maya_base.cmds.connectAttr("{}.outColorR".format(file_node),
                                                "{}.{}".format(self.shader, connect_attr), f=True)

    def disconnect_file_to_shader(self, file_node, connect_attr, is_color):
        if not self.shader:
            raise AttributeError('shader not created')
        if is_color:
            self.maya_base.cmds.disconnectAttr("{}.outColor".format(file_node),
                                               "{}.{}".format(self.shader, connect_attr), f=True)
        else:
            if self.maya_base.cmds.nodeType(file_node) == "file":
                self.maya_base.cmds.disconnectAttr("{}.outAlpha".format(file_node),
                                                   "{}.{}".format(self.shader, connect_attr), f=True)
            else:
                self.maya_base.cmds.disconnectAttr("{}.outColorR".format(file_node),
                                                   "{}.{}".format(self.shader, connect_attr), f=True)

    def connect_file_to_node(self, file_node, connect_node, is_color):
        if not self.maya_base.cmds.ls(connect_node) or not self.maya_base.cmds.ls(file_node):
            raise AttributeError('node not created')
        if is_color:
            self.maya_base.cmds.connectAttr("{}.outColor".format(file_node), connect_node, f=True)
        else:
            if self.maya_base.cmds.nodeType(file_node) == "file":
                self.maya_base.cmds.connectAttr("{}.outAlpha".format(file_node), connect_node, f=True)
                self.maya_base.cmds.setAttr("{}.alphaIsLuminance".format(file_node), 1)
            else:
                self.maya_base.cmds.connectAttr("{}.outColorR".format(file_node), connect_node, f=True)

    def open_udim(self, file_node):
        self.maya_base.cmds.setAttr("{}.uvTilingMode".format(file_node), 3)

    def create_p2d_and_connect(self, file_list):
        p2d = self.maya_base.cmds.shadingNode('place2dTexture', name="place2d", asUtility=True)
        for channelFiles in file_list:
            self.maya_base.cmds.connectAttr(p2d + ".outUV", channelFiles + ".uvCoord")
            self.maya_base.cmds.connectAttr(p2d + ".outUvFilterSize", channelFiles + ".uvFilterSize")
            self.maya_base.cmds.connectAttr(p2d + ".vertexCameraOne", channelFiles + ".vertexCameraOne")
            self.maya_base.cmds.connectAttr(p2d + ".vertexUvOne", channelFiles + ".vertexUvOne")
            self.maya_base.cmds.connectAttr(p2d + ".vertexUvThree", channelFiles + ".vertexUvThree")
            self.maya_base.cmds.connectAttr(p2d + ".vertexUvTwo", channelFiles + ".vertexUvTwo")
            self.maya_base.cmds.connectAttr(p2d + ".coverage", channelFiles + ".coverage")
            self.maya_base.cmds.connectAttr(p2d + ".mirrorU", channelFiles + ".mirrorU")
            self.maya_base.cmds.connectAttr(p2d + ".mirrorV", channelFiles + ".mirrorV")
            self.maya_base.cmds.connectAttr(p2d + ".noiseUV", channelFiles + ".noiseUV")
            self.maya_base.cmds.connectAttr(p2d + ".offset", channelFiles + ".offset")
            self.maya_base.cmds.connectAttr(p2d + ".repeatUV", channelFiles + ".repeatUV")
            self.maya_base.cmds.connectAttr(p2d + ".rotateFrame", channelFiles + ".rotateFrame")
            self.maya_base.cmds.connectAttr(p2d + ".rotateUV", channelFiles + ".rotateUV")
            self.maya_base.cmds.connectAttr(p2d + ".stagger", channelFiles + ".stagger")
            self.maya_base.cmds.connectAttr(p2d + ".translateFrame", channelFiles + ".translateFrame")
            self.maya_base.cmds.connectAttr(p2d + ".wrapU", channelFiles + ".wrapU")
            self.maya_base.cmds.connectAttr(p2d + ".wrapV", channelFiles + ".wrapV")


class MayaShaderPy2:
    def __init__(self):
        self.maya_base = MayaBasePy2()

    def export_material_info(self, yaml_file, render_type):
        """
            获取材质和物体信息 -》导入到yaml文件中

        :param yaml_file: 保持yaml文件路径
        :param render_type: 渲染器类型
        :return:
        """
        yaml_parent = os.path.dirname(yaml_file)
        yaml_dict = {}
        if not os.path.exists(yaml_parent):
            os.makedirs(yaml_parent)
        shader_attribute = get_shader_attribute_data()
        if render_type == RenderType.Arnold:
            need_attributes = shader_attribute.get(RenderType.Arnold.name)
        elif render_type == RenderType.Redshift:
            need_attributes = shader_attribute.get(RenderType.Redshift.name)
        self.maya_base.cmds.select(cl=1)
        objects = self.maya_base.cmds.ls(type="mesh", l=True)
        for obj in objects:
            obj_material = self.maya_base.cmds.listConnections(obj, type="shadingEngine")
            if not obj_material:
                continue
            for shading_connection in self.maya_base.cmds.listConnections(obj_material):
                mat = self.maya_base.cmds.ls(shading_connection, mat=1)
                if not mat:
                    continue
                if mat == ["lambert1"]:
                    continue
                mat = mat[0]
                attribute_dict = {}
                for attribute in need_attributes:
                    attribute_dict[attribute] = self.maya_base.cmds.getAttr("{}.{}".format(obj, attribute))
                yaml_dict[obj] = {"renderType": render_type.name, "material": mat, "attributes": attribute_dict}

        with open(yaml_file, "w") as f:
            yaml.safe_dump(yaml_dict, f)

    @staticmethod
    def apply_mat_from_abc_config(abc_file, abc_material_config, material_file):
        # reference abc file
        maya_file = MayaFileOperatorPy2()
        abc_new_node = maya_file.load_reference(abc_file)
        file_name = os.path.splitext(os.path.basename(abc_file))[0]
        if not abc_new_node:
            raise AttributeError("abc file is empty")
        mesh_list = []
        for node in abc_new_node:
            mesh_node = MayaAttributePy2(node)
            if mesh_node.type != "mesh":
                continue
            mesh_list.append(mesh_node)
        # get material info data
        with open(abc_material_config, "r") as f:
            abc_material_data = yaml.safe_load(f)
        # start import material maya file
        maya_file.import_file(material_file)
        for abc_node in mesh_list:
            for info_outline, material_attribute in abc_material_data.items():
                info_outline = '|'.join([i.split(':')[-1] for i in
                                         info_outline.split("|")]) if ":" in info_outline else info_outline
                if str(info_outline).endswith(
                        abc_node.maya_node.path.replace(
                            "{}:".format(file_name) if ":" in abc_node.maya_node.path else "{}_".format(file_name),
                            "")):
                    # skip displacement shader
                    if "displacement" in material_attribute.get("material"):
                        continue
                    maya_shader = MayaShader()
                    maya_shader.assign_shader(abc_node, material_attribute.get("material"))
                    attrs = material_attribute.get("attributes")
                    for attr, value in attrs.items():
                        abc_node.set_attribute(attr, value)

    def export_shader(self, ma_file):
        """
            导出shader 到一个maya文件中
        Args:
            ma_file:

        Returns:

        """
        shader_list = self.get_shader_list()
        if not shader_list:
            return
        self.maya_base.cmds.select(shader_list, allDagObjects=False, noExpand=True)
        self.maya_base.mel.eval(
            'file -force -options "v=0;" -typ "mayaAscii" -es "{}"'.format(ma_file.replace('\\', '/')))

    def get_shader_list(self):
        material_list = []
        objects = self.maya_base.cmds.ls(type="mesh", l=True)
        for obj in objects:
            obj_material = self.maya_base.cmds.listConnections(obj, type="shadingEngine")
            if not obj_material:
                continue
            for shading_connection in self.maya_base.cmds.listConnections(obj_material):
                mat = self.maya_base.cmds.ls(shading_connection, mat=1)
                if not mat:
                    continue
                if mat == ["lambert1"]:
                    continue
                material_list.append(mat[0])
        return material_list

    def assign_shader(self, mesh_node, shader_node):
        mesh_node.set_select()
        self.maya_base.cmds.hyperShade(assign=shader_node)

    def get_material(self, material_type):
        return tuple(MayaAttributePy2(i) for i in self.maya_base.cmds.ls(type=material_type.value))
